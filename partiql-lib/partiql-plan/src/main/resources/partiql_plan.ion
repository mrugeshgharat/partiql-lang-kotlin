// Experimental plan representation
// - PIVOT
// - SELECT VALUE / VALUE CONSTRUCTOR

imports::{
  kotlin: [
    any::'kotlin.Any',
    ion::'com.amazon.ionelement.api.IonElement',
    type::'org.partiql.lang.types.StaticType',
  ],
}

// Grouping of common fields without implications of interfaces or inheritance
common::{
  schema: map::[string,type],
  properties: set::[property],
  metas: map::[string,any],
}

property::[
  ORDERED,
]

// Operators that return binding collections
rel::[
  // FROM <rex>
  scan::{
    common: common,
    rex: rex,
    alias: optional::string,
    at: optional::string,
    by: optional::string,
  },
  // WHERE, HAVING
  filter::{
    common: common,
    input: rel,
    condition: rex,
  },
  // ORDER BY
  sort::{
    common: common,
    input: rel,
    specs: list::[sort_spec],
  },
  // UNION, INTERSECT, EXCEPT
  bag::{
    common: common,
    lhs: rel,
    rhs: rel,
    op: [ UNION, INTERSECT, EXCEPT ],
  },
  // LIMIT, OFFSET, FETCH
  fetch::{
    common: common,
    input: rel,
    limit: rex,
    offset: rex,
  },
  // SELECT
  project::{
    common: common,
    input: rel,
    bindings: list::[binding]
  },
  // FROM x, y / FROM x JOIN y
  join::{
    common: common,
    lhs: rel,
    rhs: rel,
    condition: optional::rex,
    type: [ INNER, LEFT, RIGHT, FULL ],
  },
  // SELECT <aggregate calls> [GROUP BY <groups>]
  aggregate::{
    common: common,
    input: rel,
    calls: list::[binding],
    groups: list::[binding],
    strategy: [ FULL, PARTIAL ]
  },
]

// Operators that return any value
rex::[
  id::{
    name: string,
  },
  path::{
    root: rex,
    // TODO
  },
  unary::{
    rex: rex,
    op: [ NOT, POS, NEG, ],
  },
  binary::{
    lhs: rex,
    rhs: rex,
    op: [
      PLUS, MINUS, TIMES, DIV, MODULO, CONCAT,
      AND, OR,
      EQ, NEQ, GTE, GT, LT, LTE,
    ],
  },
  call::{
    id: string,
    args: list::[rex],
  },
  agg::{
    id: string,
    args: list::[rex],
    modifier: [ ALL, DISTINCT ],
    // filter: rex â€” later SQL feature, not sure if we'll support this
  },
  lit::{
    value: ion,
  },
  collection::{
    type: [ LIST, BAG, SEXP ],
    values: list::[rex],
  },
  struct::{
    fields: list::[struct_part],
  },
  subquery::[
    tuple::{
      rel: rel,
    },
    scalar::{
      rel: rel,
    },
  ],
]

// Same as partiql.ion struct / struct_part
// Consider consolidating Rel Binding with struct_part.field
struct_part::[
  fields::{
    rex: rex,
  },
  field::{
    name: rex,
    rex: rex,
  },
]

// Consider defining in `_` once supported
sort_spec::{
  rex: rex,
  dir: [ ASC, DESC ],
  nulls: [ FIRST, LAST ],
}

// Representation of `rex AS name` in projections
binding::{
  name: string,
  rex: rex,
}
