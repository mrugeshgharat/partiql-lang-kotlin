// Experimental plan representation

imports::{
  kotlin: [
    any::'kotlin.Any',
    ion::'com.amazon.ionelement.api.IonElement',
    static_type::'org.partiql.lang.types.StaticType',
  ],
}

// Top-Level structure for a PartiQL Plan
plan::{
  version: [ PARTIQL_V0 ],
  root: rex,
}

// Grouping of common fields without implications of interfaces or inheritance
common::{
  schema: list::[attribute],
  properties: set::[property],
  metas: map::[string,any],
}

attribute::{
  name: string,
  type: static_type
}

// Relation properties
property::[
  ORDERED,
]

// Representation of `<rex> AS <name>` in projections
binding::{
  name: string,
  value: rex,
}

// Representation of `a_i : e_i` where a and e are expressions
field::{
  name: rex,
  value: rex,
}

// Identifier case rules
case::[
  SENSITIVE,
  INSENSITIVE,
]

// Define in `_` once supported
step::[
  key::{
    value: rex,
    case: optional::case,
  },
  wildcard::{},
  unpivot::{},
]

// Define in `_` once supported
sort_spec::{
  value: rex,
  dir: [ ASC, DESC ],
  nulls: [ FIRST, LAST ],
}

// Operators that return binding collections
rel::[
  // FROM <rex> [AS <string>] [AT <string>] [BY <string>]
  scan::{
    common: common,
    value: rex,
    alias: optional::string,
    at: optional::string,
    by: optional::string,
  },
  // UNPIVOT <rex> [AS <string>] [AT <string>] [BY <string>]
  unpivot::{
    common: common,
    value: rex,
    alias: optional::string,
    at: optional::string,
    by: optional::string,
  },
  // WHERE, HAVING
  filter::{
    common: common,
    input: rel,
    condition: rex,
  },
  // ORDER BY
  sort::{
    common: common,
    input: rel,
    specs: list::[sort_spec],
  },
  // UNION, INTERSECT, EXCEPT
  bag::{
    common: common,
    lhs: rel,
    rhs: rel,
    op: [ UNION, INTERSECT, EXCEPT ],
  },
  // LIMIT, OFFSET, FETCH
  fetch::{
    common: common,
    input: rel,
    limit: rex,
    offset: rex,
  },
  // SELECT
  project::{
    common: common,
    input: rel,
    bindings: list::[binding],
  },
  // FROM x, y / FROM x JOIN y
  join::{
    common: common,
    lhs: rel,
    rhs: rel,
    condition: optional::rex,
    type: [ INNER, LEFT, RIGHT, FULL ],
  },
  // SELECT <aggregate calls> [GROUP BY <groups>]
  aggregate::{
    common: common,
    input: rel,
    calls: list::[binding],
    groups: list::[binding],
    strategy: [ FULL, PARTIAL ],
  },
]

// Operators that return any value
rex::[
  id::{
    name: string,
    case: optional::case,
    qualifier: [ UNQUALIFIED, LOCALS_FIRST ]
  },
  path::{
    root: rex,
    steps: list::[step],
  },
  unary::{
    value: rex,
    op: [ NOT, POS, NEG, ],
  },
  binary::{
    lhs: rex,
    rhs: rex,
    op: [
      PLUS, MINUS, TIMES, DIV, MODULO, CONCAT,
      AND, OR,
      EQ, NEQ, GTE, GT, LT, LTE,
    ],
  },
  call::{
    id: string,
    args: list::[rex],
  },
  agg::{
    id: string,
    args: list::[rex],
    modifier: [ ALL, DISTINCT ],
    // filter: rex â€” later SQL feature, not sure if we'll support this
  },
  lit::{
    value: ion,
  },
  collection::{
    type: [ ARRAY, BAG ],
    values: list::[rex],
  },
  // - If binding.name is '*' and binding.rex is a struct, the fields of binding.rex are merged to this struct
  // - If binding.name is '*' and binding.rex is not a struct, the field _n will be add to this struct where n
  //   is the ordinal of the field in the final merged struct.
  // - Else, add the pair (binding.name, binding.rex) to the final merged struct.
  tuple::{
    fields: list::[field],
  },
  query::[
    scalar::[
      coerce::{
        query: '.rex.query.collection',
      },
      pivot::{
        rel: rel,
        value: rex,
        at: rex,
      },
    ],
    collection::{
      rel: rel,
      constructor: optional::rex,
    },
  ],
]
