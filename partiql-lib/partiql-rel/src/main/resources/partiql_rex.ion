// Experimental compact expression representation
// All special forms are normalized to

imports::{
  kotlin: [
    ion::'com.amazon.ionelement.api.IonElement',
  ],
}

rex::[
  id::{
    name: string,
  },
  path::{
    root: rex,
    // TODO
  },
  unary::{
    rex: rex,
    op: [ NOT, POS, NEG, ],
  },
  binary::{
    lhs: rex,
    rhs: rex,
    op: [
      PLUS, MINUS, TIMES, MODULO, CONCAT,
      AND, OR,
      EQ, NEQ, GTE, GT, LT, LTE,
    ],
  },
  call::{
    id: string,
    args: list::[rex],
  },
  agg::{
    id: string,
    args: list::[rex],
    modifier: [ ALL, DISTINCT ],
    // filter: rex â€” later SQL feature, not sure if we'll support this
  },
  lit::{
    value: ion,
  },
  collection::{
    type: [ LIST, BAG, SEXP ],
    values: list::[rex],
  },
  struct::{
    fields: list::[struct_part],
  },
]

// Same as partiql.ion struct / struct_part
// Consider consolidating Rel Binding with struct_part.field
struct_part::[
  fields::{
    rex: rex,
  },
  field::{
    name: rex,
    rex: rex,
  },
]
