imports::{
  kotlin: [
    partiql_value::'org.partiql.value.PartiQLValue',
    partiql_value_type::'org.partiql.value.PartiQLValueType',
    static_type::'org.partiql.types.StaticType',
    fn_signature::'org.partiql.spi.fn.FnSignature',
    agg_signature::'org.partiql.spi.fn.AggSignature',
    problem::'org.partiql.errors.Problem'
  ],
}

parti_q_l_plan::{
  statement:  statement,            // (statement ...)
}

// Reference to some item in a catalog.
// In the internal plan, we inline additional typing information.
// When transforming to the public plan we produce a symbol table,
// replacing each internal ref with a pointer ref to the public plan's catalog list.

ref::[
  obj::{
    catalog: string,
    path: list::[string],
    type: static_type,
  },
  fn::{
    catalog: string,
    path: list::[string],
    signature: fn_signature,
  },
  agg::{
    catalog: string,
    path: list::[string],
    signature: agg_signature,
  },
  _::[
    cast::{
      input: partiql_value_type,
      target: partiql_value_type,
      safety: [
        COERCION, // Lossless CAST(V AS T) -> T
        EXPLICIT, // Lossy    CAST(V AS T) -> T
        UNSAFE,   //          CAST(V AS T) -> T|MISSING
      ],
      isNullable: bool
    }
  ]
]

// Statements

statement::[
  query::{
    root: rex,
  },
  d_d_l::{
    shape: static_type,
    op: ddl_op,
  },
]

ddl_op::[
  // create table is a syntax sugar for creating a bag of struct
  // that is a named collection of records/structs/tuples
  //  One challenge is that SQL syntax mixes
  //  collection constraint, tuple constraint, and attribute constraints
  //  By the end of planning, we attempts to rearrange the constriants in the right place
  // Consider:
  // QUERY:
  //  CREATE TABLE tbl (
  //      a INT2 NOT NULL
  //  )
  // Plan:
  //  create_table::{
  //     name: tbl,
  //     record: struct (field(name: a, type: int2, attribute_constraint: not null)), struct_constraint: []
  //     constraint: []
  // }
  // Static Type:
  //  bag(struct(a: int2)))
  //
  // Query:
  // CREATE TABLE tbl (
  //   a INT2 UNIQUE
  // )
  // Plan:
  //  create_table::{
  //     name: tbl,
  //     record: struct (field(name: a, type: int2, attribute_constraint:[])), struct_constraint: []
  //     constraint: [UNIQUE(a)]
  // }
  // Static Type:
  //   bag(struct(a: unionOf(int2, null)), collection_constraint: <unique_constraint(a))>)

  // It is worth to call out that constraint may have multiple side effects
  // For example:
  // CREATE TABLE tbl (
  //   a INT2 PRIMARY KEY
  // )

  // Plan:
  //  create_table::{
  //     name: tbl,
  //     record: struct (field(name: a, type: int2, attribute_constraint:[])), struct_constraint: []
  //     constraint: [PRIMARY_KEY(a)]
  // }
  // Static Type:
  //   bag(struct(a: int2), collection_constraint: <primary_key(a))>)
  // Notice that in the above case, the static type associated with field a is INT2
  //  comparing with the UNIQUE example,
  // in which the static type associcated with field a is unionOf(int2, null)

  // One caveat is the check constraint
  // At the moment, all check constraint will be stored at tuple level.
  // regardless of whether it is a tuple level check constraint or a attribute level check constraint
  create_table::{
    // Table Name, unresolved
    name: identifier,
    shape: '.type.collection',
//    constraints: list::[constraint],
    partition_by: optional::partition_by,
    // table proproties:
    table_properties: list::[table_property],
  },
]

type::[
  atomic::[
    bool::{},                                                    // BOOL
    int2::{},                                                    // INT2 | INTEGER2
    int4::{},                                                    // INT4 | INTEGER4
    int8::{},                                                    // INT8
    int::{},                                                     // INTEGER
    float64::{},                                                 // DOUBLE PRECISION
    decimal::{                                                   // DECIMAL [([<int> [,<int>])]
      precision:  optional::int,
      scale:      optional::int,
    },
    char::{ length: optional::int },                             // CHARACTER [(<int>)] | CHAR [(<int>)]
    varchar::{ length: optional::int },                          // CHARACTER VARYING [(<int>)] | VARCHAR [(<int>)]
    date::{},                                                    // DATE
    time::{ precision: optional::int },                          // TIME [(<int>)] [WITHOUT TIMEZONE]
    time_with_tz::{ precision: optional::int },                  // TIME [(<int>)] WITH TIMEZONE
    timestamp::{ precision: optional::int },                     // TIMESTAMP [(<int>)] [WITHOUT TIMEZONE]
    timestamp_with_tz::{ precision: optional::int },             // TIMESTAMP [(<int>)] WITH TIMEZONE
  ],
//  collection::[
//    bag::{},                                                     // BAG
//    array::{ type: optional::type },                             // ARRAY [<type>]
//  ],


  // record is a thin wrapper over struct
  // the primary purporse was to add the support for adding struct level constraints
  // Consider if we have
  //  CREATE TABLE tbl (
  //    a STRUCT(b INT2)
  //  )
  //  create_table:: (
  //    name : tbl,
  //    record: {type: struct(...), constraints: []}
  //  )
  //
  record::{
    fields: list::[field],
    constraints: list::[constraint],
    _:[
      field::{
        name: '.identifier.symbol',
        type: type,
        constraints: list::[constraint],
        is_optional: bool,
        comment: optional::string,
      }
    ]
  },
  // Similar to the above, the collection type is a thin wrapper over bag/struct
  // which allows us to hold constraints over collection type.
  collection::{
    type: optional::type,
    is_ordered: bool,
    constraints: list::[constraint]
  },
]

// Constraints
// needed for DDL and DML.
constraint::{
  // Keep this optional at the internal plan node so it is easier to sanitize...
  name: optional::string,
  definition: [
    check::{
      lowered: rex, // check expression in rex
      sql: string, // check expression in sql text
    },
    unique::{
      attributes: list::['.identifier.symbol'],
      is_primary_key: bool,
    },
    not_null::{},
    nullable::{},
  ],
}

partition_by::[
  attr_list::{
    attrs: list::['.identifier.symbol']
  }
]

table_property::{
  name: string,
  value: partiql_value,
}

// Identifiers

identifier::[
  symbol::{
    symbol:           string,
    case_sensitivity: case_sensitivity,
  },
  qualified::{
    root:   symbol,
    steps:  list::[symbol],
  },
  _::[
    case_sensitivity::[
      SENSITIVE,
      INSENSITIVE,
    ],
  ],
]

// Rex
rex::{
  type: static_type,
  op:[

    lit::{
      value: partiql_value,
    },

    var::[
      // Refers to a value in the variables environment.
      local::{
        depth: int, // A depth of 0 would indicate that the variable is coming from the current variable scope
        ref: int,   // Value reference within the scope
      },
      // Refers to a value in the database environment.
      global::{
        ref: '.ref.obj',
      },
      unresolved::{
        identifier: identifier,
        scope: scope,
      },
      _::[
        scope::[
          DEFAULT,  //  x.y.z
          LOCAL,    // @x.y.z
        ],
      ],
    ],

    path::[
      // The key MUST be an integer expression. Ex: a[0], a[1 + 1]
      index::{ root: rex, key: rex },

      // Case-sensitive lookup. The key MUST be a string expression. Ex: a["b"], a."b", a[CAST(b AS STRING)]
      key::{ root: rex, key: rex },

      // Case-insensitive lookup. The key MUST be a literal string. Ex: a.b
      symbol::{ root: rex, key: string },
    ],

    cast::[
      unresolved::{
        target: partiql_value_type,
        arg:    rex,
      },
      resolved::{
        cast: '.ref.cast',
        arg: rex,
      }
    ],

    call::[

      unresolved::{
        identifier: identifier,
        args: list::[rex],
      },

      static::{
        fn: '.ref.fn',
        args: list::[rex],
      },

      // Represents a dynamic function call. If all candidates are exhausted, dynamic calls will return MISSING.
      //
      // args: represent the original typed arguments. These will eventually be wrapped by coercions from [candidates].
      // candidates: represent the potentially applicable resolved functions with coercions. Each of these candidates
      //  should be overloaded functions of the same name and number of arguments.
      dynamic::{
        args: list::[rex],
        candidates: list::[candidate],
        exhaustive: bool,
        _: [
          candidate::{
            fn: '.ref.fn',
            coercions: list::[optional::'.ref.cast'],
          }
        ]
      },
    ],

    case::{
      branches: list::[branch],
      default: rex,
      _: [
        branch::{
          condition:  rex,
          rex:        rex,
        },
      ],
    },

    nullif::{
      value: rex,
      nullifier: rex
    },

    coalesce::{
      args: list::[rex]
    },

    collection::{
      values: list::[rex],
    },

    struct::{
      fields: list::[field],
      _: [
        field::{
          k: rex,
          v: rex,
        },
      ],
    },

    pivot::{
      key:    rex,
      value:  rex,
      rel:    rel,
    },

    subquery::{
      constructor:  rex,
      rel:          rel,
      coercion:     [ SCALAR, ROW ],
    },

    select::{
      constructor:  rex,
      rel:          rel,
    },

    // SELECT v1.*, e2 AS a, v3.*
    //
    // SELECT VALUE TUPLEUNION(
    //   CASE WHEN v1 IS TUPLE THEN v1 ELSE {'_1': v1} END,
    //   {'a':e2 },
    //   CASE WHEN v3 IS TUPLE THEN v3 ELSE {'_2': v3} END
    // )
    //
    // Tuple Union Function Signature: (Array<Struct>) -> Struct
    tuple_union::{
      args: list::[rex],
    },

    // Internal Error Node:
    // Upon encounter an error, i.e., unknown_function(1)
    // The an error node will be popoluated in the plan to replace the top node
    // i.e.,
    // |_ Rex.Op.Call.Unresolved["unknown_function"]
    //    |_ Lit[value=Int32ValueImpl(value = 1))]
    // will be come
    // |_ Rex.Op.Err[Problem(location = ...., message = "unknown function `unknown function...`)]
    //    |_ Lit[value=Int32ValueImpl(value = 1))]
    err::{
      problem: problem,
      causes: list::['.rex.op'],
    },

    // Internal MISSING Node:
    // Upon encounter an operation that always returns missing,
    // i.e., t.a where a does not exist in t
    // The an mising node will be popoluated in the plan to replace the top node
    // i.e.,
    //
    missing::{
      problem: problem,
      causes: list::['.rex.op'],
    },
  ],
}

// Rel

rel::{
  type: {
    schema: list::[binding],
    props:  set::[prop],
  },
  op: [

    scan::{
      rex: rex,
    },

    scan_indexed::{
      rex: rex,
    },

    unpivot::{
      rex:  rex,
    },

    distinct::{
      input: rel,
    },

    filter::{
      input:      rel,
      predicate:  rex,
    },

    sort::{
      input: rel,
      specs: list::[spec],
      _: [
        spec::{
          rex: rex,
          order: order,
        },
        order::[
          ASC_NULLS_LAST,
          ASC_NULLS_FIRST,
          DESC_NULLS_LAST,
          DESC_NULLS_FIRST,
        ],
      ],
    },


    // In each variant, is_outer is an internal-only field. It is specifically used to aid in typing the plan and throwing potential errors.
    // For example, if a user were to write: `<< { 'a': 1 } >>` UNION << { 'b': 'hello' } >>, then this would FAIL
    // due to [RFC-0007](https://github.com/partiql/partiql-lang/blob/main/RFCs/0007-rfc-bag-operators.md). However,
    // if a user were to use OUTER UNION, then it would work. Under the hood at execution, the operator is the same --
    // however, at planning time, with static type analysis, we can fail queries prior to their execution.
    set::[
      union::{
        quantifier: quantifier,
        lhs: rel,
        rhs: rel,
        is_outer: bool
      },

      intersect::{
        quantifier: quantifier,
        lhs: rel,
        rhs: rel,
        is_outer: bool
      },

      except::{
        quantifier: quantifier,
        lhs: rel,
        rhs: rel,
        is_outer: bool
      },

      _::[
        quantifier::[ ALL, DISTINCT ],
      ]
    ],

    limit::{
      input:  rel,
      limit:  rex,
    },

    offset::{
      input:  rel,
      offset: rex,
    },

    project::{
      input:        rel,
      projections:  list::[rex],
    },

    join::{
      lhs: rel,
      rhs: rel,
      rex: rex, // The Join Expression (required) (can be set to TRUE)
      type: [
        INNER, // Inner Join
        LEFT,  // Left Outer Join
        RIGHT, // Right Outer Join
        FULL   // Full Outer Join
      ],
    },

    aggregate::{
      input:    rel,
      strategy: [ FULL, PARTIAL ],
      calls:    list::[call],
      groups:   list::[rex],
      _: [
        call::[
          unresolved::{
            name: string,
            set_quantifier: set_quantifier,
            args: list::[rex],
          },
          resolved::{
            agg:  '.ref.agg',
            set_quantifier: set_quantifier,
            args: list::[rex],
          },
        ],
        set_quantifier::[ ALL, DISTINCT ]
      ],
    },

    exclude::{
      input: rel,
      paths: list::[path],
      _: [
        path::{
          root: '.rex.op',
          steps: list::[step],
        },
        step::{
          type: type,
          substeps: list::[step],
        },
        type::[
          struct_symbol::{ symbol: string },
          struct_key::{ key: string },
          coll_index::{ index: int },
          struct_wildcard::{},
          coll_wildcard::{},
        ]
      ],
    },

    err::{
      message: string,
    },
  ],
  _: [
    prop::[
      ORDERED,
    ],
    binding::{
      name: string,
      type: static_type,
    },
  ]
}
