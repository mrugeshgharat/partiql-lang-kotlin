imports::{
  kotlin: [
    ion::'com.amazon.ionelement.api.IonElement',
  ],
}

statement::[

  // PartiQL Expressions
  query::{
    expr: expr,
  },

  // Data Manipulation Language
  d_m_l::[

    // INSERT INTO <target> [AS <alias>] <values> [<on conflict>]
    insert::{
      target:       identifier,
      values:       expr,
      alias:        optional::identifier,
      on_conflict:  optional::on_conflict,
    },

    // INSERT INTO <path> VALUE <expr> [AT <expr>] [<on conflict legacy>]
    insert_legacy::{
      target:             path,
      value:              expr,
      index:              optional::expr,
      conflict_condition: optional::expr,
    },

    // UPSERT INTO <target> [<alias>] <values>
    upsert::{
      target: identifier,
      values: expr,
    },

    // REPLACE INTO <target> [<alias>] <values>
    replace::{
      target: identifier,
      values: expr,
    },

    // UPDATE <target> SET <set clause list> WHERE <expr>
    update::{
      target:      path,
      assignments: list::[assignment],
      _: [
        assignment::{
          target: path,
          value:  expr,
        },
      ],
    },

    // REMOVE <path>
    remove::{
      target: path,
    },

    // DELETE [FROM] <path> [ WHERE <expr> ] RETURNING ...
    delete::{
      from:       path,
      where:      optional::expr,
      returning:  optional::returning,
    },

    // [UPDATE|FROM] <target> <dml base op>+ WHERE <expr> RETURNING <returning>
    batch_legacy::{
      target:     from,
      ops:        list::[op],
      where:      optional::expr,
      returning:  optional::returning,
      _: [
        op::[
          insert::{
            target:       identifier,
            values:       expr,
            alias:        optional::identifier,
            on_conflict:  optional::on_conflict,
          },
          insert_legacy::{
            target:             path,
            value:              expr,
            index:              optional::expr,
            conflict_condition: optional::expr,
          },
          set::{
            assignments: list::[assignment],
          },
          remove::{
            target: path,
          },
          delete::{},
        ],
      ],
    },
  ],

  // Data Definition Language
  d_d_l::[

    // CREATE TABLE <identifier> [<table_def>]
    create_table::{
      name:       identifier,
      definition: optional::table_definition,
    },

    // CREATE INDEX [<identifier>] ON <identifier> (<path> [, <path>]...)
    create_index::{
      name:   optional::identifier,
      table:  identifier,
      fields: list::[path],
    },

    // DROP TABLE <identifier>
    drop_table::{
      table: identifier,
    },

    // DROP INDEX <identifier> ON <identifier>
    drop_index::{
      index:  identifier, // <identifier>[0]
      table:  identifier, // <identifier>[1]
    },
  ],

  // EXEC <symbol> [<expr>.*]
  exec::{
    procedure: string,
    args: list::[expr],
  },

  // EXPLAIN
  explain::{
    target: [
      domain::{
        statement:  statement,
        type:       optional::string,
        format:     optional::string,
      },
    ],
  },
]

type::{
  identifier: string,
  parameters: list::[ion], // not recursive
}

// Identifiers and Qualified Identifiers
//----------------------------------------------
// <identifier > ::= <id symbol> | <id path>
//
// <id symbol> ::=  <symbol>    // case-insensitive
//               | "<symbol>"   // case-sensitive
//
// <id qualified> ::= <id symbol> ('.' <id symbol>)+;
//
identifier::[
  symbol::{
    symbol:           string,
    case_sensitivity: case_sensitivity,
  },
  qualified::{
    root:   symbol,
    steps:  list::[symbol],
  },
  _::[
    case_sensitivity::[
      SENSITIVE,
      INSENSITIVE,
    ],
  ],
]

// Path Literals
//  - Much like qualified identifier but allowing bracket notation '[' <int> | <string> ']'
//  - Not a variant of `identifier`, as path literals are not explicit in the specification.
path::{
  root:   '.identifier.symbol',
  steps:  list::[step],
  _: [
    step::[
      symbol::{
        symbol: '.identifier.symbol',
      },
      index::{
        index: int,
      },
    ],
  ],
}

// [ ALL | DISTINCT ]
set_quantifier::[
  ALL,
  DISTINCT,
]

// PartiQL Expression
expr::[

  // The MISSING value
  missing::{},

  // Literal value
  literal::{
    value: ion,
  },

  // A variable reference,
  var::{
    identifier: identifier,
    scope: [
      UNQUALIFIED, //  x.y.z
      LOCAL,       // @x.y.z
    ],
  },

  // Expression Paths
  path::{
    root:   expr,
    steps:  list::[step],
    _: [
      step::[
        index::{ key: expr },
        wildcard::{},
        unpivot::{},
      ],
    ],
  },

  // Scalar Function Call — for now, `function` is just a single identifier
  call::{
    function: string,
    args:     list::[expr],
  },

  // Aggregate Function Call
  agg::{
    function: string,
    args:     list::[expr],
    setq:     set_quantifier,
  },

  // A parameter `?`
  parameter::{
    index: int,
  },

  // Unary Operators
  unary::{
    op:   [ NOT, POS, NEG ],
    expr: expr,
  },

  // Binary Operators
  binary::{
    op: [
      PLUS, MINUS, TIMES, DIVIDE, MODULO, CONCAT,
      AND, OR,
      EQ, NE, GT, GTE, LT, LTE
    ],
    lhs: expr,
    rhs: expr,
  },

  // Collection Constructors
  collection::{
    type:   [ BAG, ARRAY, LIST, SEXP ], // syntax `<< >>`, `[ ]`, `[VALUES|LIST] ( )`, `SEXP ( )`
    values: list::[expr],
  },

  // Struct Constructor
  struct::{
    fields: list::[field],
    _: [
      field::{
        name:   expr,
        value:  expr,
      },
    ],
  },

  // Date Literal
  date::{
    year:   long,
    month:  long,
    day:    long,
  },

  // Time Literal
  time::{
    hour:               int,
    minute:             int,
    second:             int,
    nano:               int,
    precision:          int,
    with_tz:            bool,
    tz_offset_minutes:  optional::int,
  },

  // The `like` SQL special form
  like::{
    value:    expr,
    pattern:  expr,
    escape:   optional::expr,
  },

  // The `between` SQL special form
  between::{
    value:  expr,
    from:   expr,
    to:     expr,
  },

  // The `in` SQL special form
  in_collection::{
    lhs: expr,
    rhs: expr,
  },

  // The `is` PartiQL special form
  is_type::{
    value:  expr,
    type:   '.type',
  },

  // The simple and searched `case` switch SQL special form F261-01, F261-02
  case::{
    expr:     optional::expr,
    branches: list::[branch],
    default:  optional::expr,
    _: [
      branch::{
        condition:  expr,
        expr:       expr,
      },
    ],
  },

  // The `coalesce` SQL special form F261-04
  coalesce::{
    args: list::[expr],
  },

  // The `nullif` SQL special form F261-03
  null_if::{
    value:    expr,
    nullifer: expr,
  },

  // The `cast` SQL special form F201
  cast::{
    value:    expr,
    as_type:  '.type',
  },

  // The `can_cast` PartiQL special form
  can_cast::{
    value:    expr,
    as_type:  '.type',
  },

  // The `can_lossless_cast` PartiQL special form
  can_lossless_cast::{
    value:    expr,
    as_type:  '.type',
  },

  // The `<expr> OUTER (UNION|INTERSECT|EXCEPT) [ALL|DISTINCT] <expr>` PartiQL multiset special forms
  outer_set_op::{
    type: '.set_op',
    lhs:  expr,
    rhs:  expr,
  },

  // The PartiQL `sfw` query expression, think SQL <query specification>
  s_f_w::{
    select:   select,              // oneof SELECT / SELECT VALUE / PIVOT
    from:     from,
    let:      optional::let,
    where:    optional::expr,
    group_by: optional::group_by,
    having:   optional::expr,
    set_op:   optional::{
      type:    '.set_op',
      operand: '.expr.s_f_w',
    },
    order_by: optional::order_by,
    limit:    optional::expr,
    offset:   optional::expr,
  },

  // GPML ( <expr> MATCH <pattern> )
  match::{
    expr:     expr,
    pattern:  graph_match,
  },

  // WINDOW
  // OVER ([PARTITION BY <expr> [, <expr>]... ] [ORDER BY <sort_spec> [, <sort_spec>]... ])
  window::{
    function: string,
    args:     list::[expr],
    over: {
      partitions: list::[expr],
      sorts:      list::[sort],
    },
  },
]

// PartiQL SELECT Clause Variants — https://partiql.org/dql/select.html
select::[

  // SELECT [ALL|DISTINCT] *
  star::{
    setq: optional::set_quantifier,
  },

  // SELECT [ALL|DISTINCT] <select-list>
  project::{
    setq:   optional::set_quantifier,
    items:  list::[item],
    _: [
      item::[
        all::{ expr: expr },                                    // <expr>.*
        expression::{ expr: expr, as_alias: optional::string }  // <expr> [as <identifier>]
      ],
    ],
  },

  // PIVOT <expr> AT <expr>
  pivot::{
    value:  expr,
    key:    expr,
  },

  // SELECT [ALL|DISTINCT] VALUE <expr>
  value::{
    setq:         optional::set_quantifier,
    constructor:  expr,
  },
]

// PartiQL FROM Clause Variants — https://partiql.org/dql/from.html
from::[

  // FROM [UNPIVOT] <expr> [AS <identifier>] [AT <identifier>] [BY <identifier>]
  value::{
    expr:     expr,
    type:     [ SCAN, UNPIVOT ],
    as_alias: optional::string,
    at_alias: optional::string,
    by_alias: optional::string,
  },

  // <from> JOIN [INNER|LEFT|RIGHT|FULL] <from> [ON <expr>]
  join::{
    type:       [ INNER, LEFT, RIGHT, FULL ],
    condition:  optional::expr,
    lhs:        from,
    rhs:        from,
  },
]

let::{
  bindings: list::[binding],
  _: [
    binding::{
      expr:     expr,
      as_alias: string,
    },
  ],
}

// GROUP BY Clause — https://partiql.org/dql/group_by.html
group_by::{
  strategy: [ FULL, PARTIAL ],
  keys:     list::[key],
  as_alias: optional::string,
  _: [
    key::{
      expr:     expr,
      as_alias: optional::string,
    },
  ],
}

// ORDER BY Clause — https://partiql.org/dql/order_by.html
order_by::{
  sorts: list::[sort],
}

// <expr> [ASC|DESC] [NULLS FIRST | NULLS LAST]
sort::{
  expr:   expr,
  dir:    optional::[ ASC, DESC ],
  nulls:  optional::[ FIRST, LAST ],
}

// (UNION|INTERSECT|EXCEPT) [ALL|DISTINCT]
set_op::{
  setq: optional::set_quantifier,
  type: [ UNION, INTERSECT, EXCEPT ],
}

// Graph Match Nodes — https://partiql.org/gpml/graph_query.html
graph_match::{
  patterns: list::[pattern],
  selector: optional::selector,

  _: [
    pattern::{
      restrictor: optional::restrictor,
      prefilter:  optional::expr,       // An optional pattern pre-filter, e.g.: `WHERE a.name=b.name` in `MATCH [(a)->(b) WHERE a.name=b.name]`
      variable:   optional::string,     // The optional element variable of the pattern, e.g.: `p` in `MATCH p = (a) −[t]−> (b)`
      quantifier: optional::quantifier, // An optional quantifier for the entire pattern match, e.g. `{2,5}` in `MATCH (a:Account)−[:Transfer]−>{2,5}(b:Account)`
      parts:      list::[part],         // The ordered pattern parts
      _: [
        part::[
          // A single node in a graph pattern
          node::{
            prefilter:  optional::expr,    // An optional node pre-filter, e.g.: `WHERE c.name='Alarm'` in `MATCH (c WHERE c.name='Alarm')`
            variable:   optional::string,  // The optional element variable of the node match, e.g.: `x` in `MATCH (x)`
            label:      list::[string],    // The optional label(s) to match for the node, e.g.: `Entity` in `MATCH (x:Entity)`
          },
          // A single edge in a graph pattern
          edge::{
            direction:  direction,            // Edge Direction
            quantifier: optional::quantifier, // An optional quantifier for the entire pattern match, e.g. `{2,5}` in `MATCH (a:Account)−[:Transfer]−>{2,5}(b:Account)`
            prefilter:  optional::expr,       // An optional edge pre-filter, e.g.: `WHERE t.capacity>100` in `MATCH −[t:hasSupply WHERE t.capacity>100]−>`
            variable:   optional::string,     // The optional element variable of the edge match, e.g.: `t` in `MATCH −[t]−>`
            label:      list::[string],       // The optional label(s) to match for the edge. e.g.: `Target` in `MATCH −[t:Target]−>`
          },
          // A sub-pattern
          pattern::{
            pattern: '.graph_match.pattern'
          },
        ],
      ],
    },

    // Edge Direction           // | Orientation               | Edge pattern | Abbreviation |
    direction::[                // |---------------------------+--------------+--------------|
      LEFT,                     // | Pointing left             | <−[ spec ]−  | <−           |
      UNDIRECTED,               // | Undirected                | ~[ spec ]~   | ~            |
      RIGHT,                    // | Pointing right            | −[ spec ]−>  | −>           |
      LEFT_OR_UNDIRECTED,       // | Left or undirected        | <~[ spec ]~  | <~           |
      UNDIRECTED_OR_RIGHT,      // | Undirected or right       | ~[ spec ]~>  | ~>           |
      LEFT_OR_RIGHT,            // | Left or right             | <−[ spec ]−> | <−>          |
      LEFT_UNDIRECTED_OR_RIGHT, // | Left, undirected or right | −[ spec ]−   | −            |
    ],                          // Fig. 5 — https://arxiv.org/abs/2112.06217

    // Path Restrictor        // | Keyword        | Description
    restrictor::[             // |----------------+--------------
      TRAIL,                  // | TRAIL          | No repeated edges.
      ACYCLIC,                // | ACYCLIC        | No repeated nodes.
      SIMPLE,                 // | SIMPLE         | No repeated nodes, except that the ﬁrst and last nodes may be the same.
    ],                        // Fig. 7 — https://arxiv.org/abs/2112.06217

    // Graph Edge Quantifier (e.g., the `{2,5}` in `MATCH (x)->{2,5}(y)`)
    quantifier::{
      lower: long,
      upper: optional::long,
    },

    // Path Selector
    selector::[
      any_shortest::{},               // ANY SHORTEST
      all_shortest::{},               // ALL SHORTEST
      any::{},                        // ANY
      any_k::{ k: long },             // ANY k
      shortest_k::{ k: long },        // SHORTEST k
      shortest_k_group::{ k: long },  // SHORTEST k GROUP
    ],                                // Fig. 8 — https://arxiv.org/abs/2112.06217
  ],
}

// `ON CONFLICT WHERE <expr> <conflict_action>`
// `ON CONFLICT [<target>] <conflict_action>`
on_conflict::{
  target: optional::target,
  action: [
    do_replace::{ value: value },
    do_update::{ value: value },
    do_nothing::{},
  ],
  _: [
    value::[ EXCLUDED ],
    target::[
      condition::{ condition: expr },
      symbols::{ symbols: list::[string] },
      constraint::{ constraint: string },
    ],
  ],
}

// RETURNING returningColumn ( COMMA returningColumn )*
returning::{
  columns: list::[column],
  _: [
    column::{
      status: [ MODIFIED, ALL ],
      age:    [ OLD, NEW ],
      value:  [
        wildcard::{},
        expression::{ expr: expr }
      ],
    },
  ],
}

// `<column_name> <type> <column_constraint>*`
// `( CONSTRAINT <column_constraint_name> )?  <column_constraint_def>`
table_definition::{
  columns: list::[column],
  _: [
    column::{
      name:        string,
      type:        '.type',
      constraints: list::[constraint],
      _: [
        // TODO improve modeling language to avoid these wrapped unions
        // Also, prefer not to nest more than twice
        constraint::{
          name: optional::string,
          body: [
            nullable::{},
            not_null::{},
            check::{ expr: expr },
          ],
        },
      ],
    },
  ],
}
